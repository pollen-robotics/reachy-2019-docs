<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Control The Arm"><meta property="og:title" content="Control The Arm"><meta property="og:description" content="Control the arm Once you have instantiated the Reachy object, you are actually connected to your robot. This means that the hardware (sensors and effectors) are synced with their software equivalent. This synchronization loop runs at about 100Hz. In particular, this lets you retrieve the arm(s) state and send commands to make it move.
Before actually running some commands, it's important to make sure you are ready:
 Make sure the robot is in a &ldquo;safe&rdquo; state (as shown in the images below for instance)."><meta property="og:type" content="article"><meta property="og:url" content="https://pollen-robotics.github.io/reachy-2019-docs/docs/program-your-robot/control-the-arm/"><title>Control The Arm | Reachy manual</title><link rel=icon href=/reachy-2019-docs/favicon.png type=image/x-icon><link rel=stylesheet href=/reachy-2019-docs/book.min.b7fe34b8a4c4da05b2690b4aacfa71ddce0668cc6da3abb67dd3946844125444.css integrity="sha256-t/40uKTE2gWyaQtKrPpx3c4GaMxto6u2fdOUaEQSVEQ="><script defer src=/reachy-2019-docs/en.search.min.d4726a0516b761b82bdbbd710772eb757966988c8214a99bf49561afac20a0c2.js integrity="sha256-1HJqBRa3Ybgr271xB3LrdXlmmIyCFKmb9JVhr6wgoMI="></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-92714924-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js>MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script></head><body><input type=checkbox class=hidden id=menu-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/reachy-2019-docs><span>Reachy manual</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/reachy-2019-docs/docs/getting-started/>Getting Started</a><ul><li><a href=/reachy-2019-docs/docs/getting-started/install-your-robot/>Install your robot</a></li><li><a href=/reachy-2019-docs/docs/getting-started/connect-to-your-robot/>Connect to Your Robot</a></li><li><a href=/reachy-2019-docs/docs/getting-started/check-status/>Check the status of Reachy</a></li><li><a href=/reachy-2019-docs/docs/getting-started/faq/>FAQ</a></li></ul></li><li><a href=/reachy-2019-docs/docs/posts/safety/>Safety First</a></li><li><a href=/reachy-2019-docs/docs/technical-specifications/>Technical Specifications</a><ul><li><a href=/reachy-2019-docs/docs/technical-specifications/arm/>Arm</a></li><li><a href=/reachy-2019-docs/docs/technical-specifications/gripper/>Gripper</a></li><li><a href=/reachy-2019-docs/docs/technical-specifications/head/>Head</a></li><li><a href=/reachy-2019-docs/docs/technical-specifications/torso/>Torso</a></li></ul></li><li><a href=/reachy-2019-docs/docs/program-your-robot/>Program your robot</a><ul><li><a href=/reachy-2019-docs/docs/program-your-robot/instantiate-your-robot/>Instantiate Your Robot</a></li><li><a href=/reachy-2019-docs/docs/program-your-robot/control-the-arm/ class=active>Control The Arm</a></li><li><a href=/reachy-2019-docs/docs/program-your-robot/control-the-head/>Control The Head</a></li><li><a href=/reachy-2019-docs/docs/program-your-robot/pick-and-place/>Pick and Place</a></li><li><a href=/reachy-2019-docs/docs/program-your-robot/ai/>AI & Coral TPU</a></li><li><a href=/reachy-2019-docs/docs/program-your-robot/python-api/>Python's API</a></li></ul></li><li><a href=/reachy-2019-docs/docs/tictactoe/>TicTacToe Playground</a><ul><li><a href=/reachy-2019-docs/docs/tictactoe/setup-the-demo/>Setup The Demo</a></li><li><a href=/reachy-2019-docs/docs/tictactoe/playing-with-reachy/>Playing With Reachy</a></li><li><a href=/reachy-2019-docs/docs/tictactoe/train-your-own-detection/>Train Your Own Vision Detection</a></li></ul></li><li><a href=/reachy-2019-docs/docs/simulation/>Reachy simulation</a><ul><li><a href=/reachy-2019-docs/docs/simulation/create-your-own-scene/>Create your own virtual scene for Reachy</a></li></ul></li><li><span>Appendices</span><ul><li><a href=/reachy-2019-docs/docs/appendices/install-from-scratch-raspberry/>Install from Scratch on a Raspberry-Pi</a></li><li><a href=/reachy-2019-docs/docs/appendices/flash-luos-module/>Flash a Luos module</a></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/reachy-2019-docs/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Control The Arm</strong>
<label for=toc-control><img src=/reachy-2019-docs/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><input type=checkbox class=hidden id=toc-control><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#moving-individual-motors>Moving individual motors</a><ul><li><a href=#compliant-or-stiff>Compliant or stiff</a></li><li><a href=#setting-a-new-target-position-for-a-motor>Setting a new target position for a motor</a></li><li><a href=#goto-vs-goal_position>goto vs goal_position</a></li></ul></li><li><a href=#moving-multiple-motors-at-once>Moving multiple motors at once</a></li><li><a href=#different-trajectory-interpolation>Different trajectory interpolation</a></li><li><a href=#grasping>Grasping</a></li><li><a href=#record--replay-trajectories>Record & Replay Trajectories</a><ul><li><a href=#record-by-demonstration>Record by demonstration</a></li><li><a href=#replay-a-trajectory>Replay a trajectory</a></li><li><a href=#work-on-a-trajectory---smoothing>Work on a trajectory - Smoothing</a></li></ul></li><li><a href=#arm-coordinate-system>Arm coordinate system</a><ul><li><a href=#joint-coordinates>Joint coordinates</a></li><li><a href=#kinematic-model>Kinematic model</a></li><li><a href=#forward-kinematics>Forward kinematics</a></li><li><a href=#inverse-kinematics>Inverse kinematics</a></li></ul></li><li><a href=#motor-temperature-and-security>Motor temperature and security</a></li></ul></nav></aside></header><article class=markdown><h1 id=control-the-arm>Control the arm</h1><p>Once you have instantiated the <em>Reachy</em> object, you are actually connected to your robot. This means that <strong>the hardware (sensors and effectors) are synced with their software equivalent</strong>. This synchronization loop runs at about 100Hz. In particular, this lets you retrieve the arm(s) state and send commands to make it move.</p><p><strong>Before actually running some commands, it's important to make sure you are ready</strong>:</p><ul><li>Make sure the robot is in a &ldquo;safe&rdquo; state (as shown in the images below for instance). If a wire is blocked or a motor is completly reversed, sending target position or even turning the motor on may result in a violent motion that may damage the robot.</li><li>The motor are powerful so they can make the whole arm move fluidly. Do not hesitate to first try the move you want to make, with a low speed (we will show how to do that below). When you are sure everything is okay, you can increase the speed again.</li></ul><img src=/reachy-2019-docs/img/reachy-safe-position.jpg alt width=50%><blockquote class="book-hint danger">More information is available on the <a href=../posts/safety>Safety first section</a>. It provides simple guidelines to avoid damaging your robot.</blockquote><blockquote class="book-hint warning">In the examples below, we will show examples on a right arm. Using the left arm instead should be straightforward.
Always make sure that the different commands suggested below make sense in your context:</p><ul><li>angles from a right arm to a left arm may differ</li><li>if your robot is attached in front of a desk or can freely move</li><li>etc.</li></ul></blockquote><p>Everything is setup? It's time to make Reachy move!</p><h2 id=moving-individual-motors>Moving individual motors</h2><p>Reachy's upper arm is composed of 4 motors:</p><ul><li><em>shoulder_pitch</em></li><li><em>shoulder_roll</em></li><li><em>arm_yaw</em></li><li><em>elbow_pitch</em></li></ul><p>And depending on the hand used, usually 3 or 4 others motors. For the force gripper, you have:</p><ul><li><em>forearm_yaw</em></li><li><em>wrist_pitch</em></li><li><em>wrist_roll</em></li><li><em>gripper</em></li></ul><p>Each of these motors can be controlled individually.</p><blockquote class="book-hint info">Higher-level ways to control the whole arm are shown in the next sections.</blockquote><p>They are servo motors that you <strong>control in position</strong>. You can also control their <strong>compliancy</strong> or their <strong>torque limit</strong>. Theses motors are also behaving as sensor, so their <strong>present position</strong> can also be read at any time.</p><p>To access a specific motor (here <em>elbow_pitch</em>) in Python code:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>elbow_pitch
<span style=color:#f92672>&gt;&gt;</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&lt;</span>DxlMotor <span style=color:#e6db74></span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>right_arm.elbow_pitch</span><span style=color:#e6db74>&#34;</span> pos<span style=color:#f92672>=</span><span style=color:#e6db74></span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>-83.209</span><span style=color:#e6db74>&#34;</span> mode<span style=color:#f92672>=</span><span style=color:#e6db74></span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>stiff</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>&gt;</span>
</code></pre></div><p>And to get its present position:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>elbow_pitch<span style=color:#f92672>.</span>present_position
<span style=color:#f92672>&gt;&gt;</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>83.121</span>
</code></pre></div><blockquote class="book-hint info">The codes above assume that you already instantiated your Reachy, as shown in the section <a href=../instantiate-your-robot/>Instantiate Your Robot</a> and assigned it to the <em>reachy</em> variable.</blockquote><p>In a more general manner, you can access any motor by using <code>reachy.part_name.motor_name</code>.</p><blockquote class="book-hint info"><p>Please note that the part name can also be nested (e.g. <em>right_arm.hand</em>). All available parts are:</p><ul><li><em>right_arm</em></li><li><em>right_arm.hand</em></li><li><em>left_arm</em></li><li><em>left_arm.hand</em></li><li><em>head</em></li></ul><p>If one part is not present in your robot, it's value will simply be <em>None</em>.</p></blockquote><p>For each motor, we have defined angle limits. They correspond to what moves the arm can actually make. For instance, the elbow pitch is limited from 0° to 125°. The forearm yaw can move from -150° to 150°.</p><p>The zero position of each motor is defined so as when all motors are at 0°, the arm is straight down along the trunk. For more information on the motor orientation and configuration, please refer to the section <a href=#arm-coordinate-system>Arm coordinate system</a>.</p><blockquote class="book-hint warning">While each motors has angle limits corresponding to what it can do, all combinations of these limits are not reachable! When moving a motor, you always have to take into consideration the configuration of the other motors.</blockquote><h3 id=compliant-or-stiff>Compliant or stiff</h3><p>The servo motors used in Reachy's arm have two operating modes:</p><ul><li><strong>compliant</strong>: the motors is soft and can be freely turned by hand. It cannot be controlled, setting a new target position will have no effect. Yet you can still read the motor position.</li><li><strong>stiff</strong>: the motors is hard and cannot be moved by hand. It can be controlled by setting new target position.</li></ul><p>When you turn on your robot, all motors are compliant. You can freely move Reachy's arm and place it in its base position.</p><p>To make Reachy keep its position and let you control its motors, you need to turn them stiff. To do that, you can use the <em>compliant</em> property.</p><p>For instance, to make the elbow stiff, run the following code:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>elbow_pitch<span style=color:#f92672>.</span>compliant <span style=color:#f92672>=</span> False
</code></pre></div><p>Now, the elbow should be hard, you cannot move it by hand anymore.</p><p>To turn it back compliant, simply run:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>elbow_pitch<span style=color:#f92672>.</span>compliant <span style=color:#f92672>=</span> True
</code></pre></div><h3 id=setting-a-new-target-position-for-a-motor>Setting a new target position for a motor</h3><p>Assuming the motor is now stiff, you can now make it move. Once again, make sure the target position you will set corresponds to a reachable position in your configuration.</p><p>To make our motor move, we will use the <a href=https://pollen-robotics.github.io/reachy/autoapi/reachy/parts/motor/index.html#reachy.parts.motor.DynamixelMotor.goto>goto method</a>. We will define a target position and a move duration. Let's try having our elbow at 90° in 2s:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>elbow_pitch<span style=color:#f92672>.</span>goto(
    goal_position<span style=color:#f92672>=</span><span style=color:#ae81ff>90</span>,  <span style=color:#75715e># in degrees</span>
    duration<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>,  <span style=color:#75715e># in seconds</span>
    wait<span style=color:#f92672>=</span>True,
)
</code></pre></div><p>When running this code, you should see the motor move.</p><blockquote class="book-hint warning"><p>The <em>wait=True</em> option blocks until the move is actually done. You can set it to False and the function will return immediatly.</p><p><strong>Be careful not to have two trajectories running on the same motor in parallel!</strong> This could result in an unpredicted behavior (Trajectory are not thread safe).</p></blockquote><p>Let's try to move another motor, the <em>arm_yaw</em>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>arm_yaw<span style=color:#f92672>.</span>goto(
    goal_position<span style=color:#f92672>=</span><span style=color:#ae81ff>20</span>,
    duration<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>,
    wait<span style=color:#f92672>=</span>True,
)
</code></pre></div><p>Run this code&mldr; And if you followed this documentation closely, your motor should not have moved&mldr; Can you guess why? Yes, indeed the motor is still compliant. You have to turn it stiff and then run the code above again.</p><blockquote class="book-hint warning">As a safety measure, when turning a motor stiff, its goal position is reset. This avoids to directly jump to a new position when you turn the motor stiff. Indeed, the target position is stored inside the motor and could be kept even if you restart your Python script.</blockquote><h3 id=goto-vs-goal_position>goto vs goal_position</h3><p>To control & motor in the examples above we used the <em>goto</em> method. A lower API to control the motor is to directly use the <a href=https://pollen-robotics.github.io/reachy/autoapi/reachy/parts/motor/index.html#reachy.parts.motor.DynamixelMotor.goal_position><em>goal_position</em></a> property.</p><p>Yet, you should be careful when doing so, because the motor <strong>will try to reach this new goal position as fast as it can</strong>. And it is really fast (up until ~600-700 degrees per sec)! A workaround is to also use the <em>moving_speed</em> property to set the maximum speed that the motor can reach.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>elbow_pitch<span style=color:#f92672>.</span>moving_speed <span style=color:#f92672>=</span> <span style=color:#ae81ff>50</span>  <span style=color:#75715e># in degrees per sec </span>
reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>elbow_pitch<span style=color:#f92672>.</span>goal_position <span style=color:#f92672>=</span> <span style=color:#ae81ff>110</span>  <span style=color:#75715e># in degrees</span>
</code></pre></div><p>Yet, in our experience, when using this approach for controlling a motor, it may be hard to follow smoothly complex trajectories and have precise timing. You only set the maximum speed but <strong>have no control over the acceleration</strong>.</p><p>The approach used in the <em>goto</em> method differs in a sense that it only using position control (the maximum speed is allowed)</p><p><strong>A full position trajectory profile is actually generated going from the current position to the goal position</strong>. This trajectory is then interpolated at a predefined frequency (100Hz) to compute all intermediary target position that should be followed before reaching the final goal position.
Depending on the interpolation mode chosen, you can have a better control over speed and acceleration. More details are given below.</p><p>For instance, the code below will make the <em>elbow_pitch</em> motor follow this curve (assuming the motor was still in 110°):</p><pre><code>reachy.right_arm.elbow_pitch.goto(
    goal_position=80,  # in degrees
    duration=1,  # in seconds
    wait=True,
    interpolation_mode='minjerk',
)
</code></pre><img src=/reachy-2019-docs/img/minjerk-example.png alt="Minimum Jerk Trajectory example" width=600px><blockquote class="book-hint info"><p>Remember to reset the maximum speed of the <em>elbow_pitch</em> before runing any <em>goto</em> on it. To reset the maximum speed of a motor (using no speed limit) simply set it to 0:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>elbow_pitch<span style=color:#f92672>.</span>moving_speed <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> 
</code></pre></div></blockquote><h2 id=moving-multiple-motors-at-once>Moving multiple motors at once</h2><p>Most of the time when controlling a robot, you want to move multiple motors at once. While you can do it by running multiple goto and using the option <em>wait=False</em>, there is a simpler way.</p><p>You can actually use a <a href=https://pollen-robotics.github.io/reachy/autoapi/reachy/index.html#reachy.Reachy.goto><em>goto</em></a> the robot level and specify a list of (motor, target_position). This will create a trajectory for each motor and run them all in parallel.</p><p>To move both arm and forearm yaw at the same time, you can run:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>reachy<span style=color:#f92672>.</span>goto(
    goal_positions<span style=color:#f92672>=</span>{
        <span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>right_arm.arm_yaw</span><span style=color:#e6db74>&#39;</span>: <span style=color:#ae81ff>45</span>,
        <span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>right_arm.hand.forearm_yaw</span><span style=color:#e6db74>&#39;</span>: <span style=color:#f92672>-</span><span style=color:#ae81ff>45</span>,
    },
    duration<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>,
    wait<span style=color:#f92672>=</span>True,
)
</code></pre></div><blockquote class="book-hint info">Note the use of the complete motor name (eg. <em>&lsquo;right_arm.hand.forearm_yaw&rsquo;</em>) as a key string in the goal_positions dict.</blockquote><p>Motors from different parts can be mixed in the same <em>goto</em>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>reachy<span style=color:#f92672>.</span>goto(
    goal_positions<span style=color:#f92672>=</span>{
        <span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>head.left_antenna</span><span style=color:#e6db74>&#39;</span>: <span style=color:#ae81ff>0</span>,
        <span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>head.right_antenna</span><span style=color:#e6db74>&#39;</span>: <span style=color:#ae81ff>0</span>,
        <span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>right_arm.elbow_pitch</span><span style=color:#e6db74>&#39;</span>: <span style=color:#ae81ff>90</span>,
    },
    duration<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>,
    wait<span style=color:#f92672>=</span>True,
)
</code></pre></div><p>You can concatenate multiple goto simply by using the <em>wait=True</em> option and running both codes sequentially:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>reachy<span style=color:#f92672>.</span>goto(
    goal_positions<span style=color:#f92672>=</span>{
        <span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>right_arm.arm_yaw</span><span style=color:#e6db74>&#39;</span>: <span style=color:#ae81ff>45</span>,
        <span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>right_arm.hand.forearm_yaw</span><span style=color:#e6db74>&#39;</span>: <span style=color:#f92672>-</span><span style=color:#ae81ff>45</span>,
    },
    duration<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>,
    wait<span style=color:#f92672>=</span>True,
)
reachy<span style=color:#f92672>.</span>goto(
    goal_positions<span style=color:#f92672>=</span>{
        <span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>right_arm.arm_yaw</span><span style=color:#e6db74>&#39;</span>: <span style=color:#ae81ff>0</span>,
        <span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>right_arm.hand.forearm_yaw</span><span style=color:#e6db74>&#39;</span>: <span style=color:#ae81ff>0</span>,
    },
    duration<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>,
    wait<span style=color:#f92672>=</span>True,
)
</code></pre></div><p>You can also define positions, save them and then directly <em>go to</em> those positions.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>first_pos <span style=color:#f92672>=</span> {
    <span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>right_arm.arm_yaw</span><span style=color:#e6db74>&#39;</span>: <span style=color:#ae81ff>0</span>,
    <span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>right_arm.hand.forearm_yaw</span><span style=color:#e6db74>&#39;</span>: <span style=color:#ae81ff>0</span>,
}
second_pos <span style=color:#f92672>=</span> {
    <span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>right_arm.arm_yaw</span><span style=color:#e6db74>&#39;</span>: <span style=color:#ae81ff>45</span>,
    <span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>right_arm.hand.forearm_yaw</span><span style=color:#e6db74>&#39;</span>: <span style=color:#f92672>-</span><span style=color:#ae81ff>45</span>,
}

<span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>3</span>):
    reachy<span style=color:#f92672>.</span>goto(goal_positions<span style=color:#f92672>=</span>first_pos, duration<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>, wait<span style=color:#f92672>=</span>True)
    reachy<span style=color:#f92672>.</span>goto(goal_positions<span style=color:#f92672>=</span>second_pos, duration<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, wait<span style=color:#f92672>=</span>True)
</code></pre></div><blockquote class="book-hint info"><p>An easy way to define a position is to actually record it directly on the robot. To do that, you can play with the compliant mode so you can freely move the robot and make it adopt the position you want.
Then, you can record its position using a code similar to:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>current_arm_position <span style=color:#f92672>=</span> {
    motor<span style=color:#f92672>.</span>name: motor<span style=color:#f92672>.</span>present_position <span style=color:#66d9ef>for</span> motor <span style=color:#f92672>in</span> reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>motors
}

current_reachy_whole_position <span style=color:#f92672>=</span> {
    motor<span style=color:#f92672>.</span>name: motor<span style=color:#f92672>.</span>present_position <span style=color:#66d9ef>for</span> motor <span style=color:#f92672>in</span> reachy<span style=color:#f92672>.</span>motors
}
</code></pre></div><p>Make sure only the motors you want to track are actually included in the position you have recorded.</p></blockquote><h2 id=different-trajectory-interpolation>Different trajectory interpolation</h2><p>All goto accept a <em>interpolation_mode</em> argument. This lets you define the way you want the trajectory to interpolate from A to B.</p><p>It cames with two basic way:</p><ul><li>linear interpolation</li><li><a href=https://ieeexplore.ieee.org/document/12075>minimum jerk</a></li></ul><p>Running the same goto (from 0° to 90°) and changing the interpolation mode from <em>linear</em> to <em>minjerk</em> will result in the two different trajectories:</p><img src=/reachy-2019-docs/img/minjerk-vs-linear.png alt="Comparison of Linear and Minjerk interpolation" width=600px><p>Note that both trajectories start and finish at the same points. Yet, the followed positions and therefore speed and acceleration differs quite a bit. The Minimum Jerk will slowly accelerate at the begining and slowly decelerate at the end.</p><blockquote class="book-hint warning">What's show in the figure above is a theoretical trajectory. The motor has a low level controller that will try to follow this curve as closely as possible. Yet, depending on the speed/acceleration that you try to reach and the motor configuration, if it has to move a big loads, the real and theoretical curves may differ.</blockquote><h2 id=grasping>Grasping</h2><p>While the motors of the Force Gripper hand can be controlled like the rest of the motors of the arm, there is an additional functionality that lets you easily close and open the gripper.</p><p>Opening the gripper is as simple as:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>hand<span style=color:#f92672>.</span>open()
</code></pre></div><p>This actually simply runs a <em>goto</em> on the gripper motor with pre-defined target position (-30°) and duration (1s).</p><p>More interestingly, you can also use the close method:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>hand<span style=color:#f92672>.</span>close()
</code></pre></div><p>This also runs a <em>goto</em> on the gripper, but it uses the force sensor inside the gripper to detect when it did grab something. It will try to automatically adjust the grip, to maintain enough force to hold the object while not forcing too much and overheat the motor.</p><p>All parameters used in the <a href=https://pollen-robotics.github.io/reachy/autoapi/reachy/parts/hand/index.html#reachy.parts.hand.ForceGripper.close>close</a> method can be adjusted depending on your needs (please refer to the the <a href=https://pollen-robotics.github.io/reachy/autoapi/reachy/parts/hand/index.html#reachy.parts.hand.ForceGripper.close>APIs</a> for more details).</p><blockquote class="book-hint danger"><p>The gripper on Reachy's end effector is not meant to hold objects for a long time. The motor used in the gripper will quickly overload if doing so. Holding objects as you can see on the TicTacToe demo for instance is a good approximation of what the robot can do for long period of time (hold ~5s rest ~10s).</p><p>If you need to hold objects for longer period of time, you probably need to have a specific gripper for this task. While this is part of Pollen Robotics plan, we do not yet have a ready-to-use solution for this kind of use. Let us know if you would be interested in such features or want to help design one.</p></blockquote><p>The Force Gripper also gives you access to the current <em>grip_force</em>. The load sensor is located inside Reachy's gripper. It measures the force applied on the gripper (exactly it measures the deformation of the gripper due to the grasping).</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>print</span>(reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>hand<span style=color:#f92672>.</span>grip_force)
<span style=color:#f92672>&gt;&gt;</span><span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>123.1</span>
</code></pre></div><blockquote class="book-hint info"><p>The returned value is nor accurate nor expressed in a standard unit system. Only relative values should be taken into account.</p><p>For instance:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>if</span> abs(reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>hand<span style=color:#f92672>.</span>grip_force) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>50</span>:
    <span style=color:#66d9ef>print</span>(<span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>not holding</span><span style=color:#e6db74>&#39;</span>)
<span style=color:#66d9ef>else</span>:
    <span style=color:#66d9ef>print</span>(<span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>holding</span><span style=color:#e6db74>&#39;</span>)
</code></pre></div></blockquote><h2 id=record--replay-trajectories>Record & Replay Trajectories</h2><p>So far, we have showed you how to make your robot move using <em>goto</em> and pre-defined position. This works well for simple motion. But sometimes you would like to have more complex motions. That's when another technique comes into place: <strong>recording by demonstration</strong>.</p><h3 id=record-by-demonstration>Record by demonstration</h3><p>With this approach, you will demonstrate whole trajectories on Reachy by moving it by hand (using the compliant mode) and record its position at high-frequency (about 100Hz). Depending on what you want, you can record a single motor, or multiple at the same time. We provide a <a href=https://pollen-robotics.github.io/reachy/autoapi/reachy/trajectory/recorder/index.html#reachy.trajectory.recorder.TrajectoryRecorder>TrajectoryRecorder</a> object that makes this process really simple.</p><p>For instance, assuming you want to record a movement on the Right Arm and that it is already compliant:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>recorder <span style=color:#f92672>=</span> TrajectoryRecorder(reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>motors)
</code></pre></div><p>And when you are ready to record:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>recorder<span style=color:#f92672>.</span>start()
</code></pre></div><p>And when the movement is over:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>recorder<span style=color:#f92672>.</span>stop()
</code></pre></div><p>The recorded trajectories can then be accessed via:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>print</span>(recorder<span style=color:#f92672>.</span>trajectories)
<span style=color:#f92672>&gt;&gt;</span><span style=color:#f92672>&gt;</span> TODO
</code></pre></div><p>You can save it as a numpy array using:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> numpy <span style=color:#f92672>as</span> np

np<span style=color:#f92672>.</span>savez(<span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>my-recorded-trajectory.npz</span><span style=color:#e6db74>&#39;</span>, <span style=color:#f92672>*</span><span style=color:#f92672>*</span>recorder<span style=color:#f92672>.</span>trajectories)
</code></pre></div><p>The recorder can be restart as many times as you want. A new trajectory will be recorded on store as <code>recorder.trajectories</code>.</p><p>You can record any list of motors. For instance if you want to record the arm yaw and the gripper you can use:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>recorded_motors <span style=color:#f92672>=</span> [reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>arm_yaw, reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>hand<span style=color:#f92672>.</span>gripper]

recorder <span style=color:#f92672>=</span> TrajectoryRecorder(recorded_motors)

recorder<span style=color:#f92672>.</span>start()
time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>10</span>)
recorder<span style=color:#f92672>.</span>stop()
</code></pre></div><h3 id=replay-a-trajectory>Replay a trajectory</h3><p>Let's say you have recorded a nice motion and save it on the disk using the code above. You can first reload it at any time using:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>my_loaded_trajectory <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>load(<span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>my-recorded-trajectory.npz</span><span style=color:#e6db74>&#39;</span>)
</code></pre></div><p>Then, you want to play it on the robot. To do that, we have created an object called <a href=https://pollen-robotics.github.io/reachy/autoapi/reachy/trajectory/player/index.html#reachy.trajectory.player.TrajectoryPlayer>TrajectoryPlayer</a>. It can be used as follow:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>trajectory_player <span style=color:#f92672>=</span> TrajectoryPlayer(reachy, my_loaded_trajectory)
</code></pre></div><p>First, you need to specify on which robot you want to play the trajectory. If you have multiple Reachy, you can record a movement on one and play it on the other.
Then, you need to specify which trajectory you want to play.</p><p>Assuming the motors you want to use to play the trajectory are stiff and that the robot is in position where he can play the trajectory:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>trajectory_player<span style=color:#f92672>.</span>play(wait<span style=color:#f92672>=</span>True, fade_in_duration<span style=color:#f92672>=</span><span style=color:#ae81ff>1.0</span>)
</code></pre></div><p>The code above will play the trajectory, wait for it to finish.</p><blockquote class="book-hint danger"><p>The <em>fade_in_duration</em> ensure there is no jump at the begining of the motion. Indeed, if you play a trajectory from a different starting point that what you record, the robot will try to reach this starting position as fast as it can. This parameter basically says, &ldquo;first goto the recorded starting position in 1s, then play the trajectory&rdquo;.</p><p>Always think about starting position before recording and replaying trajectories!</p></blockquote><p>You can also play multiple trajectories as a sequence. Assuming you have recorded three motion (traj_1, traj_2 and traj_3):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>TrajectoryPlayer(reachy, traj_1)<span style=color:#f92672>.</span>play(wait<span style=color:#f92672>=</span>True, fade_in_duration<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
TrajectoryPlayer(reachy, traj_2)<span style=color:#f92672>.</span>play(wait<span style=color:#f92672>=</span>True, fade_in_duration<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
TrajectoryPlayer(reachy, traj_3)<span style=color:#f92672>.</span>play(wait<span style=color:#f92672>=</span>True, fade_in_duration<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</code></pre></div><p>or in a more concise way:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>for</span> traj <span style=color:#f92672>in</span> [traj_1, traj_2, traj_3]:
    TrajectoryPlayer(reachy, traj)<span style=color:#f92672>.</span>play(wait<span style=color:#f92672>=</span>True, fade_in_duration<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</code></pre></div><h3 id=work-on-a-trajectory---smoothing>Work on a trajectory - Smoothing</h3><p>Recorded trajectories are actually simple objects. It's a dict in the form:</p><p><code>{motor_name: numpy_array_of_position}</code></p><p>Position arrays have the same length for all motors. You can thus convert the whole trajectory as a 2D array of shape <em>MxS</em> where <em>M</em> is the number of motor and <em>S</em> is the number of sample in the trajectory. The number of sample corresponds roughly to the duration in seconds x 100 (the default sampling frequency).</p><p>By recording a trajectory by demonstration, you may sometimes also record involuntary movements or jerkiness. When replayed, you may observe such artefacts. A good practice is to actually apply some smoothing/filtering on the trajectory before saving it.</p><p>As they are store as <a href=https://numpy.org>numpy arrays</a>, you can use all typical libraries for this task (numpy/scipy/etc). Depending on the type of movements you recorded or what you want to do (eg. really smooth and slow moves, accurate trajectory, etc), the smoothing you want to apply may vary and there is not a single approach that will work for all types of moves.</p><p>We still provide a <em>cubic smooth</em> functionalities as it is something we often use. The <a href="https://pollen-robotics.github.io/reachy/autoapi/reachy/trajectory/interpolation/index.html?highlight=cubic#reachy.trajectory.interpolation.cubic_smooth">cubic smoothing</a> will garantee to have continuous acceleration which is really important for human perception. You simply need to choose the number of keypoints that will be used to represent your smoothed trajectory.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>from</span> reachy.trajectory.interpolation <span style=color:#f92672>import</span> cubic_smooth

smoothed_trajectories <span style=color:#f92672>=</span> cubic_smooth(recorder<span style=color:#f92672>.</span>trajectories, nb_kp<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>)
</code></pre></div><blockquote class="book-hint info">The cubic smooth function will keep the same number of samples by default. But you can modify this behavior using the <em>out_points</em> parameters.</blockquote><h2 id=arm-coordinate-system>Arm coordinate system</h2><h3 id=joint-coordinates>Joint coordinates</h3><p>In all examples above, we have used what is called joint coordinates. This means that we have controlled each joint separately.</p><h3 id=kinematic-model>Kinematic model</h3><p>Controlling a robot in joint coordinates can be hard and is often far from what we actually do as humans. When we want to grasp an object in front of us, we think of where we should put our hand, not how to flex each individual muscle to reach this position. This approach relies on the cartesian coordinates: the 3D position and orientation in space.</p><p>Forward and Inverse Kinematics is a way to go from one coordinates system to the other:</p><ul><li>forward kinematics: joint coordinates &ndash;> cartesian coordinates</li><li>inverse kinematics: cartesian coordinates &ndash;> joint coordinates</li></ul><p>We have defined the whole kinematic model of the arm. This means the translation and rotation required to go from one joint to the next one. On a right arm equipped with a force gripper this actually look like this:</p><table><thead><tr><th>Motor</th><th>Translation</th><th>Rotation</th></tr></thead><tbody><tr><td>shoulder_pitch</td><td>(0, -0.19, 0)</td><td>(0, 1, 0)</td></tr><tr><td>shoulder_roll</td><td>(0, 0, 0)</td><td>(1, 0, 0)</td></tr><tr><td>arm_yaw</td><td>(0, 0, 0)</td><td>(0, 0, 1)</td></tr><tr><td>elbow_pitch</td><td>(0, 0, -0.28)</td><td>(0, 1, 0)</td></tr><tr><td>forearm_yaw</td><td>(0, 0, 0)</td><td>(0, 0, 1)</td></tr><tr><td>wrist_pitch</td><td>(0, 0, -0.25)</td><td>(0, 1, 0)</td></tr><tr><td>wrist_roll</td><td>(0, 0, -0.0325)</td><td>(1, 0, 0)</td></tr><tr><td>gripper</td><td>(0, -0.01, -0.075)</td><td>(0, 0, 0)</td></tr></tbody></table><p>This describe the translation and rotation needed to go from the previous motor to the next one. We actually use a simplified Denavit Hartenberg notation.</p><img src=/reachy-2019-docs/img/reachy-arm-plan-front.png alt width=50%><p>To use and understand kinematic model, you need to know how Reachy coordinate system is defined (from Reachy's perspective):</p><ul><li>The <em>X</em> axis corresponds to the foward arrow.</li><li>The <em>Y</em> axis corresponds to the right to left arrow.</li><li>The <em>Z</em> axis corresponds to the up arrow.</li></ul><p>And the origin of this coordinate system is located in the upper part of the robot trunk. Basically, if you imagine a segment going from the left shoulder to the right shoulder of the robot, the origin is the middle of this segment.</p><p>The units used for this coordinate system are the meter. So the point (0.3, -0.2, 0) is 30cm in front of the origin, 20cm to the right and at the same height.</p><h3 id=forward-kinematics>Forward kinematics</h3><p>Using the joint coordinates and the kinematic model defined above, we can actually compute the 3D position and orientation of any joint in the arm. This question can be formalized as a trigonometry problem and it's called the forward kinematics.</p><p>We provide a function to directly compute the forward kinematics of a reachy arm. Assuming you are working on a Right Arm with a Force Gripper (8 joints), you can find the pose when all motors are at their zero position:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>print</span>(reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>forward_kinematics(joints_position<span style=color:#f92672>=</span>[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>]))
<span style=color:#f92672>&gt;&gt;</span><span style=color:#f92672>&gt;</span> array([[ <span style=color:#ae81ff>1.</span>     ,  <span style=color:#ae81ff>0.</span>     ,  <span style=color:#ae81ff>0.</span>     ,  <span style=color:#ae81ff>0.</span>     ],
           [ <span style=color:#ae81ff>0.</span>     ,  <span style=color:#ae81ff>1.</span>     ,  <span style=color:#ae81ff>0.</span>     , <span style=color:#f92672>-</span><span style=color:#ae81ff>0.2</span>    ],
           [ <span style=color:#ae81ff>0.</span>     ,  <span style=color:#ae81ff>0.</span>     ,  <span style=color:#ae81ff>1.</span>     , <span style=color:#f92672>-</span><span style=color:#ae81ff>0.6375</span> ],
           [ <span style=color:#ae81ff>0.</span>     ,  <span style=color:#ae81ff>0.</span>     ,  <span style=color:#ae81ff>0.</span>     ,  <span style=color:#ae81ff>1.</span>     ]])
</code></pre></div><blockquote class="book-hint info">The 4x4 matrix returned by the forward kinematics method is what is often called a pose. It actually encodes both the 3D translation (as a 3D vector) and the 3D rotation (as a 3x3 matrix) into one single representation.
$$\begin{bmatrix}
R_{11} & R_{12} & R_{13} & T_x\\\<br>R_{21} & R_{22} & R_{23} & T_y\\\<br>R_{31} & R_{32} & R_{33} & T_z\\\<br>0 & 0 & 0 & 1
\end{bmatrix}$$</blockquote><p>You can also get the current pose by doing:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>current_position <span style=color:#f92672>=</span> [m<span style=color:#f92672>.</span>present_position <span style=color:#66d9ef>for</span> m <span style=color:#f92672>in</span> reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>motors]
<span style=color:#66d9ef>print</span>(reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>forward_kinematics(joints_position<span style=color:#f92672>=</span>current_position))
<span style=color:#f92672>&gt;&gt;</span><span style=color:#f92672>&gt;</span> array([[ <span style=color:#ae81ff>0.001</span>,  <span style=color:#ae81ff>0.</span>   , <span style=color:#f92672>-</span><span style=color:#ae81ff>1.</span>   ,  <span style=color:#ae81ff>0.316</span>],
           [ <span style=color:#ae81ff>0.</span>   ,  <span style=color:#ae81ff>1.</span>   ,  <span style=color:#ae81ff>0.</span>   , <span style=color:#f92672>-</span><span style=color:#ae81ff>0.209</span>],
           [ <span style=color:#ae81ff>1.</span>   , <span style=color:#f92672>-</span><span style=color:#ae81ff>0.</span>   ,  <span style=color:#ae81ff>0.001</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>0.308</span>],
           [ <span style=color:#ae81ff>0.</span>   ,  <span style=color:#ae81ff>0.</span>   ,  <span style=color:#ae81ff>0.</span>   ,  <span style=color:#ae81ff>1.</span>   ]])
</code></pre></div><blockquote class="book-hint warning">If you are using an external 3D tracker, you may observe a difference between your measure of the end effector and the one given by the forward kinematics. Keep in mind that the forward kinematics rely on a theoretical model of the Reachy arm. You may have difference due to motor jerk or assembly approximation.</blockquote><h3 id=inverse-kinematics>Inverse kinematics</h3><p>Knowing where you arm is located in the 3D space can be useful but most of the time what you want is to move the arm in cartesian coordinates. You want to have the possibility to say: &ldquo;move your hand to [x, y, z] with a 90° rotation around the Z axis&rdquo;.</p><p>This is what inverse kinematics does. We have provided a method to help you with that. You need to give it a 4x4 target pose (as given as a result by the forward kinematics) and an initial joint state.</p><p>To make this more concrete, let's first try with a simple example. We will make the hand of the robot goes from a point A to a point B in 3D space. You always have to provide poses to the inverse kinematics that are actually reachable by the robot.</p><p>For our starting point, let's imagine a point in front of the robot rigth shoulder and slightly below. If you remember Reachy coordinate system, we can define such a point with the following coordinates: $$A=(0.3, -0.2, -0.3)$$</p><p>For our end point we will stay in a parallel plan in front of the robot (we keep the same x) and move to the upper left (20cm up and 20cm left). This gives us a B point such that:</p><p>$$B=(0.3, 0.0, -0.1)$$</p><p>But having the 3D position is not enough to design a pose. You also need to provide the 3D orientation. The identity rotation matrix corresponds to the zero position of the robot, ie. when the hand is facing toward the bottom. So if we want the hand facing forward when going from A to B, we need to rotate it from -90° around the y axis.</p><img src=/reachy-2019-docs/img/reachy-arm-plan-side.png alt width=75%><p>The corresponding matrix can be obtained from scipy:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>from</span> scipy.spatial.transform <span style=color:#f92672>import</span> Rotation <span style=color:#66d9ef>as</span> R

<span style=color:#66d9ef>print</span>(R<span style=color:#f92672>.</span>from_euler(<span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>y</span><span style=color:#e6db74>&#39;</span>, np<span style=color:#f92672>.</span>deg2rad(<span style=color:#f92672>-</span><span style=color:#ae81ff>90</span>))<span style=color:#f92672>.</span>as_matrix(), <span style=color:#ae81ff>2</span>)
<span style=color:#f92672>&gt;&gt;</span><span style=color:#f92672>&gt;</span> array([[ <span style=color:#ae81ff>0.</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>0.</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1.</span>],
           [ <span style=color:#ae81ff>0.</span>,  <span style=color:#ae81ff>1.</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>0.</span>],
           [ <span style=color:#ae81ff>1.</span>,  <span style=color:#ae81ff>0.</span>,  <span style=color:#ae81ff>0.</span>]])
</code></pre></div><p>By combining the position and orientation, this give us the following poses:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>A <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array((
    (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,  <span style=color:#ae81ff>0.3</span>),
    (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>,  <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>0.2</span>),
    (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>0.3</span>),
    (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>1</span>),
))

B <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array((
    (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,  <span style=color:#ae81ff>0.3</span>),
    (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>,  <span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>0.0</span>),
    (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>0.1</span>),
    (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>1</span>),
))
</code></pre></div><blockquote class="book-hint info"><p>Finding the correct poses may be tricky, especially the orientation. You can always use the forward kinematics, with joint positions that corresponds roughly to where you are trying reach, to get a reference position and orientation.</p><p>The inverse kinematics is also often used in combination with an external tracking system that can provide 3D pose of predefined object. In such case, you only need to make sure to express all pose in the same coordintate system.</p></blockquote><p>The basic inverse kinematics used for Reachy relies on optimisation techniques. Results will thus largely depend on the initial guess you provide (if you are not supplying one, the current joints position of the robot will be used).</p><p>In our case, we can imagine that a base position could corresponds to moving the elbow to -90 to face forward, thiss give us the full joint position to be [0, 0, 0, -90, 0, 0, 0, 0].</p><p>If we put everything together, we can now ask the inverse kinematics to compute the joint position that corresponds to our A and B poses:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>
JA <span style=color:#f92672>=</span> reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>inverse_kinematics(A, q0<span style=color:#f92672>=</span>[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>90</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>])
<span style=color:#66d9ef>print</span>(np<span style=color:#f92672>.</span>round(JA, <span style=color:#ae81ff>2</span>))
<span style=color:#f92672>&gt;&gt;</span><span style=color:#f92672>&gt;</span> [<span style=color:#ae81ff>3.1</span>, <span style=color:#ae81ff>0.9</span>, <span style=color:#ae81ff>0.82</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>94.39</span>, <span style=color:#ae81ff>1.18</span>, <span style=color:#ae81ff>0.43</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>0.8</span>, <span style=color:#ae81ff>0.</span>]

JB <span style=color:#f92672>=</span> reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>inverse_kinematics(B, q0<span style=color:#f92672>=</span>[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>90</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>])
<span style=color:#66d9ef>print</span>(np<span style=color:#f92672>.</span>round(JB, <span style=color:#ae81ff>2</span>))
<span style=color:#f92672>&gt;&gt;</span><span style=color:#f92672>&gt;</span> [<span style=color:#f92672>-</span><span style=color:#ae81ff>21.25</span>, <span style=color:#ae81ff>10.</span>, <span style=color:#ae81ff>42.65</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>110.79</span>, <span style=color:#ae81ff>16.46</span>, <span style=color:#ae81ff>39.25</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>28.3</span>, <span style=color:#ae81ff>0.</span>]
</code></pre></div><p>You can then define a goto_right_arm_joint_solution and use it to go from A to B:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> time

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>goto_right_arm_joint_solution</span>(joint_solution, duration, wait):
    reachy<span style=color:#f92672>.</span>goto({
        m<span style=color:#f92672>.</span>name: j
        <span style=color:#66d9ef>for</span> j, m <span style=color:#f92672>in</span> zip(joint_solution, reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>motors)
    }, duration<span style=color:#f92672>=</span>duration, wait<span style=color:#f92672>=</span>wait)

goto_right_arm_joint_solution(JA, duration<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>, wait<span style=color:#f92672>=</span>True)

time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>2</span>)

goto_right_arm_joint_solution(JB, duration<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>, wait<span style=color:#f92672>=</span>True)
</code></pre></div><p>You should have seen the robot follow the 3D line that we defined!</p><p>Inverse kinematics is a really powerful way to define motions in coordinate systems that fits better with the defintion of many tasks (grasp the bottle in (x, y, z) for instance). Yet, this approach has also some important limitations.</p><p>First, it's important to understand that while the forward kinematics has a unique and well defined solution, the inverse kinematics is a much harder and ill defined problem. A Right Arm with a Gripper has 8 Degrees Of Freedom (8 motors) meaning that you may have multiple solutions to reach the same 3D point in space.</p><p>Second, there are many approaches to solve the inverse kinematics. The main one used in Reachy is based on an black-box optimisation technique that may take time to converge. You also need to give it a starting point that may have a tremendous influence on the final result. Other approaches can be used but they all have they pros and cons and you may use one or the other depending on the task you are trying to solve.</p><h2 id=motor-temperature-and-security>Motor temperature and security</h2><p>The motor used in Reachy arm are servo-motors and they are providing extra information.</p><p>You can get their current temperature (in °C). For instance, to get the temprature of the elbow_pitch you can simply do:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>print</span>(reachy<span style=color:#f92672>.</span>right_arm<span style=color:#f92672>.</span>elbow_pitch<span style=color:#f92672>.</span>temperature)
<span style=color:#f92672>&gt;&gt;</span><span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>34.1</span>
</code></pre></div><p>There is an automatic behavior that monitors those temperature and will turn on the fan inside the arm to cool it down if needed. A temperature above 45°C will trigger the fan, while going below 40°C will turn it off.</p><p>There is also an internal safety inside the motor that will automatically shut the motor down if it reaches 55°C. This is to avoid damaging a motor. To turn it on again, you will have to power it off and on again. There is also an overload safety. It will also shutdown the motor if the load applied on the motor is too high for a period of time. See the <a href=../../posts/safety/>Safety first section</a> for more details.</p></article><footer class=book-footer><div class="flex justify-between"><div><a class="flex align-center" href=https://github.com/pollen-robotics/reachy-2019-docs/edit/master/content/docs/program-your-robot/control-the-arm.md target=_blank rel=noopener><img src=/reachy-2019-docs/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><div class=book-comments></div></footer></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#moving-individual-motors>Moving individual motors</a><ul><li><a href=#compliant-or-stiff>Compliant or stiff</a></li><li><a href=#setting-a-new-target-position-for-a-motor>Setting a new target position for a motor</a></li><li><a href=#goto-vs-goal_position>goto vs goal_position</a></li></ul></li><li><a href=#moving-multiple-motors-at-once>Moving multiple motors at once</a></li><li><a href=#different-trajectory-interpolation>Different trajectory interpolation</a></li><li><a href=#grasping>Grasping</a></li><li><a href=#record--replay-trajectories>Record & Replay Trajectories</a><ul><li><a href=#record-by-demonstration>Record by demonstration</a></li><li><a href=#replay-a-trajectory>Replay a trajectory</a></li><li><a href=#work-on-a-trajectory---smoothing>Work on a trajectory - Smoothing</a></li></ul></li><li><a href=#arm-coordinate-system>Arm coordinate system</a><ul><li><a href=#joint-coordinates>Joint coordinates</a></li><li><a href=#kinematic-model>Kinematic model</a></li><li><a href=#forward-kinematics>Forward kinematics</a></li><li><a href=#inverse-kinematics>Inverse kinematics</a></li></ul></li><li><a href=#motor-temperature-and-security>Motor temperature and security</a></li></ul></nav></aside></main></body></html>